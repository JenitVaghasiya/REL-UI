/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.19.1.0 (NJsonSchema v9.10.72.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { OAuthService } from 'app/services/o-auth.service';
import { Globals } from 'app/globals';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class BaseClient {
  private oAuthService: OAuthService;

  constructor() {
    this.oAuthService = Globals.injector.get(OAuthService);
  }

  protected transformOptions(options: any) {
    const timestamp = new Date();
    let customHeaders = new HttpHeaders();
    customHeaders = customHeaders.append('Access-Control-Allow-Origin', '*');
    customHeaders = customHeaders.append(
      'Content-Type',
      'application/json; charset=UTF-8'
    );
    if (this.oAuthService.getAuthorizationHeader() !== '') {
      customHeaders = customHeaders.append(
        'Authorization',
        this.oAuthService.getAuthorizationHeader()
      );
    }
    customHeaders = customHeaders.append('Accept', 'application/json');
    customHeaders = customHeaders.append('Cache-Control', 'no-cache');
    customHeaders = customHeaders.append('Pragma', 'no-cache');
    customHeaders = customHeaders.append(
      'X-REL-Timezone-Offset-Mins',
      (timestamp.getTimezoneOffset() * -1).toString()
    );
    customHeaders = customHeaders.append(
      'Access-Control-Allow-Methods',
      'PUT, GET, POST, DELETE, OPTIONS'
    );
    customHeaders = customHeaders.append(
      'Access-Control-Allow-Headers',
      'Origin, X-Requested-With, Content-Type, Accept, Authorization'
    );
    options.headers = customHeaders;
    return Promise.resolve(options);
  }
}

export interface IAccountsClient {
    create(account: AccountForCreationDto): Observable<ServiceResponseOfString>;
    getAccount(id: string): Observable<ServiceResponseOfAccountDto>;
    getAccounts(): Observable<ServiceResponseOfListOfAccountDto>;
    delete(id: string): Observable<ServiceResponse>;
    update(account: AccountForUpdateDto, id: string): Observable<ServiceResponse>;
    getStateList(): Observable<ServiceResponseOfListOfStateDto>;
}

@Injectable()
export class AccountsClient extends BaseClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(account: AccountForCreationDto): Observable<ServiceResponseOfString> {
        let url_ = this.baseUrl + "/api/accounts/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfString>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfString>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponseOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfString.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfString>(<any>null);
    }

    getAccount(id: string): Observable<ServiceResponseOfAccountDto> {
        let url_ = this.baseUrl + "/api/accounts/getaccount?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccount(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfAccountDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfAccountDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAccount(response: HttpResponseBase): Observable<ServiceResponseOfAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfAccountDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfAccountDto>(<any>null);
    }

    getAccounts(): Observable<ServiceResponseOfListOfAccountDto> {
        let url_ = this.baseUrl + "/api/accounts/getaccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAccounts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccounts(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfAccountDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfAccountDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<ServiceResponseOfListOfAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfAccountDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfAccountDto>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/accounts/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(account: AccountForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/accounts/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getStateList(): Observable<ServiceResponseOfListOfStateDto> {
        let url_ = this.baseUrl + "/api/accounts/getstatelist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetStateList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfStateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfStateDto>><any>Observable.throw(response_);
        });
    }

    protected processGetStateList(response: HttpResponseBase): Observable<ServiceResponseOfListOfStateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfStateDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfStateDto>(<any>null);
    }
}

export interface IAuthClient {
    login(model: LoginModel): Observable<ServiceResponseOfProfileViewModel>;
    register(model: RegisterModel): Observable<ServiceResponseOfProfileViewModel>;
    forgotPassword(email: string): Observable<ServiceResponse>;
    resetPassword(password: string, confirmPassword: string, code: string, userId: string): Observable<ServiceResponse>;
}

@Injectable()
export class AuthClient extends BaseClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    login(model: LoginModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    register(model: RegisterModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    forgotPassword(email: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/auth/forgotpassword?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processForgotPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    resetPassword(password: string, confirmPassword: string, code: string, userId: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/auth/resetpassword?";
        if (password === undefined)
            throw new Error("The parameter 'password' must be defined.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (confirmPassword !== undefined)
            url_ += "confirmPassword=" + encodeURIComponent("" + confirmPassword) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processResetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }
}

export interface ICheckListClient {
    create(checkList: CheckListForCreationDto): Observable<ServiceResponse>;
    delete(id: string): Observable<ServiceResponse>;
    update(checkList: CheckListForUpdateDto, id: string): Observable<ServiceResponse>;
    getCheckList(id: string): Observable<ServiceResponseOfCheckListDto>;
    getListOfCheckList(institutionId: string): Observable<ServiceResponseOfListOfCheckListDto>;
}

@Injectable()
export class CheckListClient extends BaseClient implements ICheckListClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(checkList: CheckListForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklists/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(checkList: CheckListForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklists/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getCheckList(id: string): Observable<ServiceResponseOfCheckListDto> {
        let url_ = this.baseUrl + "/api/checklists/getchecklist?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetCheckList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfCheckListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfCheckListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCheckList(response: HttpResponseBase): Observable<ServiceResponseOfCheckListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfCheckListDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfCheckListDto>(<any>null);
    }

    getListOfCheckList(institutionId: string): Observable<ServiceResponseOfListOfCheckListDto> {
        let url_ = this.baseUrl + "/api/checklists/getlistofchecklist?";
        if (institutionId === undefined)
            throw new Error("The parameter 'institutionId' must be defined.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetListOfCheckList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfCheckList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfCheckListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfCheckListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetListOfCheckList(response: HttpResponseBase): Observable<ServiceResponseOfListOfCheckListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfCheckListDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfCheckListDto>(<any>null);
    }
}

export interface ICheckListItemsClient {
    create(checkListItem: CheckListItemForCreationDto): Observable<ServiceResponse>;
    delete(id: string): Observable<ServiceResponse>;
    update(checkListItem: CheckListItemDto, id: string): Observable<ServiceResponse>;
    get(id: string): Observable<ServiceResponseOfCheckListItemDto>;
    getChecklistItems(checklistId: string): Observable<ServiceResponseOfListOfCheckListItemDto>;
    updateChecklistItemsOrder(model: CheckListItemDto[]): Observable<ServiceResponse>;
}

@Injectable()
export class CheckListItemsClient extends BaseClient implements ICheckListItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(checkListItem: CheckListItemForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklistitems/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkListItem);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklistitems/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(checkListItem: CheckListItemDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklistitems/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkListItem);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    get(id: string): Observable<ServiceResponseOfCheckListItemDto> {
        let url_ = this.baseUrl + "/api/checklistitems/getlistitem?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfCheckListItemDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfCheckListItemDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<ServiceResponseOfCheckListItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfCheckListItemDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfCheckListItemDto>(<any>null);
    }

    getChecklistItems(checklistId: string): Observable<ServiceResponseOfListOfCheckListItemDto> {
        let url_ = this.baseUrl + "/api/checklistitems/getchecklistitems?";
        if (checklistId === undefined)
            throw new Error("The parameter 'checklistId' must be defined.");
        else
            url_ += "checklistId=" + encodeURIComponent("" + checklistId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetChecklistItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChecklistItems(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfCheckListItemDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfCheckListItemDto>><any>Observable.throw(response_);
        });
    }

    protected processGetChecklistItems(response: HttpResponseBase): Observable<ServiceResponseOfListOfCheckListItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfCheckListItemDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfCheckListItemDto>(<any>null);
    }

    updateChecklistItemsOrder(model: CheckListItemDto[]): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklistitems/updatechecklistitemsorder?";
        if (model !== undefined)
            model && model.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateChecklistItemsOrder(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateChecklistItemsOrder(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdateChecklistItemsOrder(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }
}

export interface IInstitutionClient {
    create(institution: InstitutionForCreationDto): Observable<ServiceResponse>;
    delete(id: string): Observable<ServiceResponse>;
    update(institution: InstitutionForUpdateDto, id: string): Observable<ServiceResponse>;
    getInstitution(id: string): Observable<ServiceResponseOfInstitutionDto>;
    getInstitutionList(accountId: string, userId: string): Observable<ServiceResponseOfListOfInstitutionDto>;
}

@Injectable()
export class InstitutionClient extends BaseClient implements IInstitutionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(institution: InstitutionForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/institutions/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(institution);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/institutions/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(institution: InstitutionForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/institutions/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(institution);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getInstitution(id: string): Observable<ServiceResponseOfInstitutionDto> {
        let url_ = this.baseUrl + "/api/institutions/getinstitution?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetInstitution(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitution(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfInstitutionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfInstitutionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInstitution(response: HttpResponseBase): Observable<ServiceResponseOfInstitutionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfInstitutionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfInstitutionDto>(<any>null);
    }

    getInstitutionList(accountId: string, userId: string): Observable<ServiceResponseOfListOfInstitutionDto> {
        let url_ = this.baseUrl + "/api/institutions/getinstitutionlist?";
        if (accountId === undefined)
            throw new Error("The parameter 'accountId' must be defined.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetInstitutionList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitutionList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfInstitutionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfInstitutionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInstitutionList(response: HttpResponseBase): Observable<ServiceResponseOfListOfInstitutionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfInstitutionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfInstitutionDto>(<any>null);
    }
}

export interface IInvestorClient {
    create(investor: InvestorForCreationDto): Observable<ServiceResponse>;
    delete(id: string): Observable<ServiceResponse>;
    update(investor: InvestorForUpdateDto, id: string): Observable<ServiceResponse>;
    getInvestorDetail(id: string): Observable<ServiceResponseOfInvestorDto>;
    getInvestorList(institutionId: string): Observable<ServiceResponseOfListOfInvestorDto>;
}

@Injectable()
export class InvestorClient extends BaseClient implements IInvestorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(investor: InvestorForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/investors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(investor);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/investors/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(investor: InvestorForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/investors/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(investor);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getInvestorDetail(id: string): Observable<ServiceResponseOfInvestorDto> {
        let url_ = this.baseUrl + "/api/investors/getinvestordetail?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetInvestorDetail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestorDetail(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfInvestorDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfInvestorDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInvestorDetail(response: HttpResponseBase): Observable<ServiceResponseOfInvestorDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfInvestorDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfInvestorDto>(<any>null);
    }

    getInvestorList(institutionId: string): Observable<ServiceResponseOfListOfInvestorDto> {
        let url_ = this.baseUrl + "/api/investors/getinvestorlist?";
        if (institutionId === undefined)
            throw new Error("The parameter 'institutionId' must be defined.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetInvestorList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestorList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfInvestorDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfInvestorDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInvestorList(response: HttpResponseBase): Observable<ServiceResponseOfListOfInvestorDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfInvestorDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfInvestorDto>(<any>null);
    }
}

export interface ILoanClient {
    create(loan: LoanForCreationDto): Observable<ServiceResponse>;
    delete(id: string): Observable<ServiceResponse>;
    update(loan: LoanForUpdateDto, id: string): Observable<ServiceResponse>;
    getLoanDetail(id: string): Observable<ServiceResponseOfLoanDto>;
    getLoanList(institutionId: string): Observable<ServiceResponseOfListOfLoanDto>;
}

@Injectable()
export class LoanClient extends BaseClient implements ILoanClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(loan: LoanForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/loans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loan);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/loans/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(loan: LoanForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/loans/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loan);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getLoanDetail(id: string): Observable<ServiceResponseOfLoanDto> {
        let url_ = this.baseUrl + "/api/loans/getloandetail?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetLoanDetail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanDetail(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfLoanDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfLoanDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLoanDetail(response: HttpResponseBase): Observable<ServiceResponseOfLoanDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfLoanDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfLoanDto>(<any>null);
    }

    getLoanList(institutionId: string): Observable<ServiceResponseOfListOfLoanDto> {
        let url_ = this.baseUrl + "/api/loans/getloanlist?";
        if (institutionId === undefined)
            throw new Error("The parameter 'institutionId' must be defined.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetLoanList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfLoanDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfLoanDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLoanList(response: HttpResponseBase): Observable<ServiceResponseOfListOfLoanDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfLoanDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfLoanDto>(<any>null);
    }
}

export interface IManageUserClient {
    inviteUser(model: InviteUserModel): Observable<ServiceResponse>;
    reInviteUser(model: InviteUserModel, oldEmail: string): Observable<ServiceResponse>;
    getRegisterdUsersByAccount(accountId: string): Observable<ServiceResponseOfListOfUserModel>;
    getRegisterdUsersByInstitution(institutionId: string): Observable<ServiceResponseOfListOfUserModel>;
    updatePasswordOfInvitedUser(model: UpdatePasswordOfInvitedUserModel): Observable<ServiceResponseOfProfileViewModel>;
    getRoles(): Observable<ServiceResponseOfListOfAspNetRoleDto>;
    getInstitutionRoles(): Observable<ServiceResponseOfListOfAspNetRoleDto>;
    updateUserDetail(model: UserModel): Observable<ServiceResponseOfProfileViewModel>;
}

@Injectable()
export class ManageUserClient extends BaseClient implements IManageUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    inviteUser(model: InviteUserModel): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/manageuser/inviteuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processInviteUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processInviteUser(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    reInviteUser(model: InviteUserModel, oldEmail: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/manageuser/reinviteuser?";
        if (oldEmail === undefined)
            throw new Error("The parameter 'oldEmail' must be defined.");
        else
            url_ += "oldEmail=" + encodeURIComponent("" + oldEmail) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processReInviteUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReInviteUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processReInviteUser(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getRegisterdUsersByAccount(accountId: string): Observable<ServiceResponseOfListOfUserModel> {
        let url_ = this.baseUrl + "/api/manageuser/getregisterdusersbyaccount?";
        if (accountId === undefined)
            throw new Error("The parameter 'accountId' must be defined.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetRegisterdUsersByAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegisterdUsersByAccount(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfUserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfUserModel>><any>Observable.throw(response_);
        });
    }

    protected processGetRegisterdUsersByAccount(response: HttpResponseBase): Observable<ServiceResponseOfListOfUserModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfUserModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfUserModel>(<any>null);
    }

    getRegisterdUsersByInstitution(institutionId: string): Observable<ServiceResponseOfListOfUserModel> {
        let url_ = this.baseUrl + "/api/manageuser/getregisterdusersbyinstitution?";
        if (institutionId === undefined)
            throw new Error("The parameter 'institutionId' must be defined.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetRegisterdUsersByInstitution(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegisterdUsersByInstitution(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfUserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfUserModel>><any>Observable.throw(response_);
        });
    }

    protected processGetRegisterdUsersByInstitution(response: HttpResponseBase): Observable<ServiceResponseOfListOfUserModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfUserModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfUserModel>(<any>null);
    }

    updatePasswordOfInvitedUser(model: UpdatePasswordOfInvitedUserModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/manageuser/updatepasswordofinviteduser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdatePasswordOfInvitedUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordOfInvitedUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePasswordOfInvitedUser(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    getRoles(): Observable<ServiceResponseOfListOfAspNetRoleDto> {
        let url_ = this.baseUrl + "/api/manageuser/getroles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfAspNetRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfAspNetRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ServiceResponseOfListOfAspNetRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfAspNetRoleDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfAspNetRoleDto>(<any>null);
    }

    getInstitutionRoles(): Observable<ServiceResponseOfListOfAspNetRoleDto> {
        let url_ = this.baseUrl + "/api/manageuser/getinstitutionroles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetInstitutionRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitutionRoles(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfAspNetRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfAspNetRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInstitutionRoles(response: HttpResponseBase): Observable<ServiceResponseOfListOfAspNetRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfAspNetRoleDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfAspNetRoleDto>(<any>null);
    }

    updateUserDetail(model: UserModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/manageuser/updateuserdetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateUserDetail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserDetail(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUserDetail(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }
}

export interface IStandardColorClient {
    getStandardColor(id: string): Observable<ServiceResponseOfStandardColorDto>;
    createStandardColor(model: StandardColorForCreationDto): Observable<ServiceResponse>;
    deleteStandardColor(id: string): Observable<ServiceResponse>;
    updateStandardColor(model: StandardColorForUpdateDto, id: string): Observable<ServiceResponse>;
    getStandardColorList(id: string): Observable<ServiceResponseOfListOfStandardColorDto>;
}

@Injectable()
export class StandardColorClient extends BaseClient implements IStandardColorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    getStandardColor(id: string): Observable<ServiceResponseOfStandardColorDto> {
        let url_ = this.baseUrl + "/api/standardcolor/getDetail?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetStandardColor(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStandardColor(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfStandardColorDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfStandardColorDto>><any>Observable.throw(response_);
        });
    }

    protected processGetStandardColor(response: HttpResponseBase): Observable<ServiceResponseOfStandardColorDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfStandardColorDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfStandardColorDto>(<any>null);
    }

    createStandardColor(model: StandardColorForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/standardcolor/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateStandardColor(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStandardColor(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreateStandardColor(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    deleteStandardColor(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/standardcolor/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteStandardColor(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStandardColor(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDeleteStandardColor(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    updateStandardColor(model: StandardColorForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/standardcolor/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateStandardColor(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStandardColor(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdateStandardColor(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getStandardColorList(id: string): Observable<ServiceResponseOfListOfStandardColorDto> {
        let url_ = this.baseUrl + "/api/standardcolor/getList?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetStandardColorList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStandardColorList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfStandardColorDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfStandardColorDto>><any>Observable.throw(response_);
        });
    }

    protected processGetStandardColorList(response: HttpResponseBase): Observable<ServiceResponseOfListOfStandardColorDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfStandardColorDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfStandardColorDto>(<any>null);
    }
}

export interface ITaskStatusClient {
    getTaskStatusSet(setId: string): Observable<ServiceResponseOfTaskStatusSetDto>;
    createTaskStatusSet(model: TaskStatusSetForCreationDto): Observable<ServiceResponse>;
    deleteTaskStatusSet(id: string): Observable<ServiceResponse>;
    updateTaskStatusSet(model: TaskStatusSetForUpdateDto, id: string): Observable<ServiceResponse>;
    getTaskStatusSetList(institutionId: string): Observable<ServiceResponseOfListOfTaskStatusSetDto>;
    getTaskStatusSets(institutionId: string): Observable<ServiceResponseOfListOfTaskStatusSetDto>;
}

@Injectable()
export class TaskStatusClient extends BaseClient implements ITaskStatusClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    getTaskStatusSet(setId: string): Observable<ServiceResponseOfTaskStatusSetDto> {
        let url_ = this.baseUrl + "/api/taststatussets/gettaskstatusset?";
        if (setId === undefined)
            throw new Error("The parameter 'setId' must be defined.");
        else
            url_ += "setId=" + encodeURIComponent("" + setId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTaskStatusSet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatusSet(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfTaskStatusSetDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfTaskStatusSetDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTaskStatusSet(response: HttpResponseBase): Observable<ServiceResponseOfTaskStatusSetDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfTaskStatusSetDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfTaskStatusSetDto>(<any>null);
    }

    createTaskStatusSet(model: TaskStatusSetForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/taststatussets/createtaskstatusset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateTaskStatusSet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaskStatusSet(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreateTaskStatusSet(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    deleteTaskStatusSet(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/taststatussets/deletetaskstatusset?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteTaskStatusSet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaskStatusSet(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDeleteTaskStatusSet(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    updateTaskStatusSet(model: TaskStatusSetForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/taststatussets/updatetaskstatusset?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateTaskStatusSet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTaskStatusSet(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTaskStatusSet(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getTaskStatusSetList(institutionId: string): Observable<ServiceResponseOfListOfTaskStatusSetDto> {
        let url_ = this.baseUrl + "/api/taststatussets/gettaskstatussetlist?";
        if (institutionId === undefined)
            throw new Error("The parameter 'institutionId' must be defined.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTaskStatusSetList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatusSetList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfTaskStatusSetDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfTaskStatusSetDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTaskStatusSetList(response: HttpResponseBase): Observable<ServiceResponseOfListOfTaskStatusSetDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfTaskStatusSetDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfTaskStatusSetDto>(<any>null);
    }

    getTaskStatusSets(institutionId: string): Observable<ServiceResponseOfListOfTaskStatusSetDto> {
        let url_ = this.baseUrl + "/api/taststatussets/gettaskstatussets?";
        if (institutionId === undefined)
            throw new Error("The parameter 'institutionId' must be defined.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTaskStatusSets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatusSets(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfTaskStatusSetDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfTaskStatusSetDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTaskStatusSets(response: HttpResponseBase): Observable<ServiceResponseOfListOfTaskStatusSetDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfTaskStatusSetDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfTaskStatusSetDto>(<any>null);
    }
}

export interface ITaskStatusDetailClient {
    getTaskStatus(id: string): Observable<ServiceResponseOfTaskStatusDetailDto>;
    createTaskStatus(model: TaskStatusDetailForCreationDto): Observable<ServiceResponse>;
    deleteTaskStatus(id: string): Observable<ServiceResponse>;
    updateTaskStatus(model: TaskStatusDetailForUpdateDto, id: string): Observable<ServiceResponse>;
    getTaskStatusList(id: string): Observable<ServiceResponseOfListOfTaskStatusDetailDto>;
    updateTaskstatusDetailOrder(updatedtaskStatusdetailList: TaskStatusDetailDto[]): Observable<ServiceResponse>;
}

@Injectable()
export class TaskStatusDetailClient extends BaseClient implements ITaskStatusDetailClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    getTaskStatus(id: string): Observable<ServiceResponseOfTaskStatusDetailDto> {
        let url_ = this.baseUrl + "/api/taskstatusdetail/gettaskstatus?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTaskStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatus(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfTaskStatusDetailDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfTaskStatusDetailDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTaskStatus(response: HttpResponseBase): Observable<ServiceResponseOfTaskStatusDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfTaskStatusDetailDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfTaskStatusDetailDto>(<any>null);
    }

    createTaskStatus(model: TaskStatusDetailForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/taskstatusdetail/createtaskstatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateTaskStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaskStatus(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreateTaskStatus(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    deleteTaskStatus(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/taskstatusdetail/deletetaskstatus?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteTaskStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaskStatus(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDeleteTaskStatus(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    updateTaskStatus(model: TaskStatusDetailForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/taskstatusdetail/updatetaskstatus?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateTaskStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTaskStatus(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTaskStatus(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getTaskStatusList(id: string): Observable<ServiceResponseOfListOfTaskStatusDetailDto> {
        let url_ = this.baseUrl + "/api/taskstatusdetail/gettaskstatuslist?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTaskStatusList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatusList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfTaskStatusDetailDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfTaskStatusDetailDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTaskStatusList(response: HttpResponseBase): Observable<ServiceResponseOfListOfTaskStatusDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfTaskStatusDetailDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfTaskStatusDetailDto>(<any>null);
    }

    updateTaskstatusDetailOrder(updatedtaskStatusdetailList: TaskStatusDetailDto[]): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/taskstatusdetail/updatetaskstatusdetailorder?";
        if (updatedtaskStatusdetailList !== undefined)
            updatedtaskStatusdetailList && updatedtaskStatusdetailList.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "updatedtaskStatusdetailList[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateTaskstatusDetailOrder(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTaskstatusDetailOrder(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTaskstatusDetailOrder(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }
}

export class AccountForCreationDto implements IAccountForCreationDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;

    constructor(data?: IAccountForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.street1 = data["street1"];
            this.street2 = data["street2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): AccountForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["street1"] = this.street1;
        data["street2"] = this.street2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IAccountForCreationDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;
}

export class ServiceResponse implements IServiceResponse {
    errorMessages?: ValidationFailure[];
    successful: boolean;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["errorMessages"] && data["errorMessages"].constructor === Array) {
                this.errorMessages = [];
                for (let item of data["errorMessages"])
                    this.errorMessages.push(ValidationFailure.fromJS(item));
            }
            this.successful = data["successful"];
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errorMessages && this.errorMessages.constructor === Array) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item.toJSON());
        }
        data["successful"] = this.successful;
        return data; 
    }
}

export interface IServiceResponse {
    errorMessages?: ValidationFailure[];
    successful: boolean;
}

export class ServiceResponseOfString extends ServiceResponse implements IServiceResponseOfString {
    data?: string;

    constructor(data?: IServiceResponseOfString) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"];
        }
    }

    static fromJS(data: any): ServiceResponseOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfString extends IServiceResponse {
    data?: string;
}

/** Defines a validation failure */
export class ValidationFailure implements IValidationFailure {
    /** The name of the property. */
    propertyName?: string;
    /** The error message */
    errorMessage?: string;
    /** The property value that caused the failure. */
    attemptedValue?: any;
    /** Custom state associated with the failure. */
    customState?: any;
    /** Custom severity level associated with the failure. */
    severity: Severity;
    /** Gets or sets the error code. */
    errorCode?: string;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[];
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; };
    /** The resource name used for building the message */
    resourceName?: string;

    constructor(data?: IValidationFailure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.errorMessage = data["errorMessage"];
            this.attemptedValue = data["attemptedValue"];
            this.customState = data["customState"];
            this.severity = data["severity"];
            this.errorCode = data["errorCode"];
            if (data["formattedMessageArguments"] && data["formattedMessageArguments"].constructor === Array) {
                this.formattedMessageArguments = [];
                for (let item of data["formattedMessageArguments"])
                    this.formattedMessageArguments.push(item);
            }
            if (data["formattedMessagePlaceholderValues"]) {
                this.formattedMessagePlaceholderValues = {};
                for (let key in data["formattedMessagePlaceholderValues"]) {
                    if (data["formattedMessagePlaceholderValues"].hasOwnProperty(key))
                        this.formattedMessagePlaceholderValues[key] = data["formattedMessagePlaceholderValues"][key];
                }
            }
            this.resourceName = data["resourceName"];
        }
    }

    static fromJS(data: any): ValidationFailure {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFailure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["customState"] = this.customState;
        data["severity"] = this.severity;
        data["errorCode"] = this.errorCode;
        if (this.formattedMessageArguments && this.formattedMessageArguments.constructor === Array) {
            data["formattedMessageArguments"] = [];
            for (let item of this.formattedMessageArguments)
                data["formattedMessageArguments"].push(item);
        }
        if (this.formattedMessagePlaceholderValues) {
            data["formattedMessagePlaceholderValues"] = {};
            for (let key in this.formattedMessagePlaceholderValues) {
                if (this.formattedMessagePlaceholderValues.hasOwnProperty(key))
                    data["formattedMessagePlaceholderValues"][key] = this.formattedMessagePlaceholderValues[key];
            }
        }
        data["resourceName"] = this.resourceName;
        return data; 
    }
}

/** Defines a validation failure */
export interface IValidationFailure {
    /** The name of the property. */
    propertyName?: string;
    /** The error message */
    errorMessage?: string;
    /** The property value that caused the failure. */
    attemptedValue?: any;
    /** Custom state associated with the failure. */
    customState?: any;
    /** Custom severity level associated with the failure. */
    severity: Severity;
    /** Gets or sets the error code. */
    errorCode?: string;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[];
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; };
    /** The resource name used for building the message */
    resourceName?: string;
}

/** Specifies the severity of a rule. */
export enum Severity {
    Error = 0, 
    Warning = 1, 
    Info = 2, 
}

export class ServiceResponseOfAccountDto extends ServiceResponse implements IServiceResponseOfAccountDto {
    data?: AccountDto;

    constructor(data?: IServiceResponseOfAccountDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? AccountDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfAccountDto extends IServiceResponse {
    data?: AccountDto;
}

export class AccountDto implements IAccountDto {
    id: string;
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.street1 = data["street1"];
            this.street2 = data["street2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["street1"] = this.street1;
        data["street2"] = this.street2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IAccountDto {
    id: string;
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;
}

export class ServiceResponseOfListOfAccountDto extends ServiceResponse implements IServiceResponseOfListOfAccountDto {
    data?: AccountDto[];

    constructor(data?: IServiceResponseOfListOfAccountDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfAccountDto extends IServiceResponse {
    data?: AccountDto[];
}

export class AccountForUpdateDto implements IAccountForUpdateDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;

    constructor(data?: IAccountForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.street1 = data["street1"];
            this.street2 = data["street2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): AccountForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["street1"] = this.street1;
        data["street2"] = this.street2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IAccountForUpdateDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;
}

export class ServiceResponseOfListOfStateDto extends ServiceResponse implements IServiceResponseOfListOfStateDto {
    data?: StateDto[];

    constructor(data?: IServiceResponseOfListOfStateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(StateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfStateDto extends IServiceResponse {
    data?: StateDto[];
}

export class StateDto implements IStateDto {
    id?: string;
    code: string;
    name: string;

    constructor(data?: IStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): StateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStateDto {
    id?: string;
    code: string;
    name: string;
}

export class LoginModel implements ILoginModel {
    email: string;
    password: string;
    rememberMe: boolean;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.password = data["password"];
            this.rememberMe = data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ILoginModel {
    email: string;
    password: string;
    rememberMe: boolean;
}

export class ServiceResponseOfProfileViewModel extends ServiceResponse implements IServiceResponseOfProfileViewModel {
    data?: ProfileViewModel;

    constructor(data?: IServiceResponseOfProfileViewModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? ProfileViewModel.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfProfileViewModel extends IServiceResponse {
    data?: ProfileViewModel;
}

export class ProfileViewModel implements IProfileViewModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    token?: string;
    accountId?: string;
    isInvited: boolean;
    phoneNumber?: string;
    emailConfirmed: boolean;

    constructor(data?: IProfileViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.token = data["token"];
            this.accountId = data["accountId"];
            this.isInvited = data["isInvited"];
            this.phoneNumber = data["phoneNumber"];
            this.emailConfirmed = data["emailConfirmed"];
        }
    }

    static fromJS(data: any): ProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["token"] = this.token;
        data["accountId"] = this.accountId;
        data["isInvited"] = this.isInvited;
        data["phoneNumber"] = this.phoneNumber;
        data["emailConfirmed"] = this.emailConfirmed;
        return data; 
    }
}

export interface IProfileViewModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    token?: string;
    accountId?: string;
    isInvited: boolean;
    phoneNumber?: string;
    emailConfirmed: boolean;
}

export class RegisterModel implements IRegisterModel {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    confirmPassword?: string;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.password = data["password"];
            this.confirmPassword = data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IRegisterModel {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    confirmPassword?: string;
}

export class CheckListForCreationDto implements ICheckListForCreationDto {
    name: string;
    institutionId?: string;

    constructor(data?: ICheckListForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): CheckListForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface ICheckListForCreationDto {
    name: string;
    institutionId?: string;
}

export class CheckListForUpdateDto implements ICheckListForUpdateDto {
    name: string;
    institutionId?: string;

    constructor(data?: ICheckListForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): CheckListForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface ICheckListForUpdateDto {
    name: string;
    institutionId?: string;
}

export class ServiceResponseOfCheckListDto extends ServiceResponse implements IServiceResponseOfCheckListDto {
    data?: CheckListDto;

    constructor(data?: IServiceResponseOfCheckListDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? CheckListDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfCheckListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfCheckListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfCheckListDto extends IServiceResponse {
    data?: CheckListDto;
}

export class BaseDto implements IBaseDto {
    id: string;
    createdDate: Date;
    modifiedDate: Date;

    constructor(data?: IBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBaseDto {
    id: string;
    createdDate: Date;
    modifiedDate: Date;
}

export class CheckListDto extends BaseDto implements ICheckListDto {
    name: string;
    institutionId?: string;
    institutionName?: string;

    constructor(data?: ICheckListDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.institutionId = data["institutionId"];
            this.institutionName = data["institutionName"];
        }
    }

    static fromJS(data: any): CheckListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        super.toJSON(data);
        return data; 
    }
}

export interface ICheckListDto extends IBaseDto {
    name: string;
    institutionId?: string;
    institutionName?: string;
}

export class ServiceResponseOfListOfCheckListDto extends ServiceResponse implements IServiceResponseOfListOfCheckListDto {
    data?: CheckListDto[];

    constructor(data?: IServiceResponseOfListOfCheckListDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CheckListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfCheckListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfCheckListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfCheckListDto extends IServiceResponse {
    data?: CheckListDto[];
}

export class CheckListItemForCreationDto implements ICheckListItemForCreationDto {
    checkListId: string;
    order: number;
    instruction: string;
    helpContext?: string;
    taskStatusSetId: string;
    disabled: boolean;

    constructor(data?: ICheckListItemForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkListId = data["checkListId"];
            this.order = data["order"];
            this.instruction = data["instruction"];
            this.helpContext = data["helpContext"];
            this.taskStatusSetId = data["taskStatusSetId"];
            this.disabled = data["disabled"];
        }
    }

    static fromJS(data: any): CheckListItemForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListItemForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkListId"] = this.checkListId;
        data["order"] = this.order;
        data["instruction"] = this.instruction;
        data["helpContext"] = this.helpContext;
        data["taskStatusSetId"] = this.taskStatusSetId;
        data["disabled"] = this.disabled;
        return data; 
    }
}

export interface ICheckListItemForCreationDto {
    checkListId: string;
    order: number;
    instruction: string;
    helpContext?: string;
    taskStatusSetId: string;
    disabled: boolean;
}

export class CheckListItemDto extends BaseDto implements ICheckListItemDto {
    checkListId: string;
    order: number;
    instruction: string;
    helpContext?: string;
    taskStatusSetId: string;
    taskStatusSetDetail?: TaskStatusSetDto;
    disabled: boolean;

    constructor(data?: ICheckListItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.checkListId = data["checkListId"];
            this.order = data["order"];
            this.instruction = data["instruction"];
            this.helpContext = data["helpContext"];
            this.taskStatusSetId = data["taskStatusSetId"];
            this.taskStatusSetDetail = data["taskStatusSetDetail"] ? TaskStatusSetDto.fromJS(data["taskStatusSetDetail"]) : <any>undefined;
            this.disabled = data["disabled"];
        }
    }

    static fromJS(data: any): CheckListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkListId"] = this.checkListId;
        data["order"] = this.order;
        data["instruction"] = this.instruction;
        data["helpContext"] = this.helpContext;
        data["taskStatusSetId"] = this.taskStatusSetId;
        data["taskStatusSetDetail"] = this.taskStatusSetDetail ? this.taskStatusSetDetail.toJSON() : <any>undefined;
        data["disabled"] = this.disabled;
        super.toJSON(data);
        return data; 
    }
}

export interface ICheckListItemDto extends IBaseDto {
    checkListId: string;
    order: number;
    instruction: string;
    helpContext?: string;
    taskStatusSetId: string;
    taskStatusSetDetail?: TaskStatusSetDto;
    disabled: boolean;
}

export class TaskStatusSetDto extends BaseDto implements ITaskStatusSetDto {
    title: string;
    disabled: boolean;
    institutionId: string;
    institutionName?: string;
    taskStatusDetail?: TaskStatusDetailDto[];

    constructor(data?: ITaskStatusSetDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.title = data["title"];
            this.disabled = data["disabled"];
            this.institutionId = data["institutionId"];
            this.institutionName = data["institutionName"];
            if (data["taskStatusDetail"] && data["taskStatusDetail"].constructor === Array) {
                this.taskStatusDetail = [];
                for (let item of data["taskStatusDetail"])
                    this.taskStatusDetail.push(TaskStatusDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaskStatusSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStatusSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["disabled"] = this.disabled;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        if (this.taskStatusDetail && this.taskStatusDetail.constructor === Array) {
            data["taskStatusDetail"] = [];
            for (let item of this.taskStatusDetail)
                data["taskStatusDetail"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITaskStatusSetDto extends IBaseDto {
    title: string;
    disabled: boolean;
    institutionId: string;
    institutionName?: string;
    taskStatusDetail?: TaskStatusDetailDto[];
}

export class TaskStatusDetailDto extends BaseDto implements ITaskStatusDetailDto {
    caption: string;
    color: string;
    backGroundColor: string;
    order: number;
    taskStatusSetId: string;
    disabled: boolean;
    taskStatusSetTitle?: string;

    constructor(data?: ITaskStatusDetailDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.caption = data["caption"];
            this.color = data["color"];
            this.backGroundColor = data["backGroundColor"];
            this.order = data["order"];
            this.taskStatusSetId = data["taskStatusSetId"];
            this.disabled = data["disabled"];
            this.taskStatusSetTitle = data["taskStatusSetTitle"];
        }
    }

    static fromJS(data: any): TaskStatusDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStatusDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caption"] = this.caption;
        data["color"] = this.color;
        data["backGroundColor"] = this.backGroundColor;
        data["order"] = this.order;
        data["taskStatusSetId"] = this.taskStatusSetId;
        data["disabled"] = this.disabled;
        data["taskStatusSetTitle"] = this.taskStatusSetTitle;
        super.toJSON(data);
        return data; 
    }
}

export interface ITaskStatusDetailDto extends IBaseDto {
    caption: string;
    color: string;
    backGroundColor: string;
    order: number;
    taskStatusSetId: string;
    disabled: boolean;
    taskStatusSetTitle?: string;
}

export class ServiceResponseOfCheckListItemDto extends ServiceResponse implements IServiceResponseOfCheckListItemDto {
    data?: CheckListItemDto;

    constructor(data?: IServiceResponseOfCheckListItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? CheckListItemDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfCheckListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfCheckListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfCheckListItemDto extends IServiceResponse {
    data?: CheckListItemDto;
}

export class ServiceResponseOfListOfCheckListItemDto extends ServiceResponse implements IServiceResponseOfListOfCheckListItemDto {
    data?: CheckListItemDto[];

    constructor(data?: IServiceResponseOfListOfCheckListItemDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CheckListItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfCheckListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfCheckListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfCheckListItemDto extends IServiceResponse {
    data?: CheckListItemDto[];
}

export class InstitutionForCreationDto implements IInstitutionForCreationDto {
    name: string;
    accountId?: string;
    userId?: string;

    constructor(data?: IInstitutionForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): InstitutionForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IInstitutionForCreationDto {
    name: string;
    accountId?: string;
    userId?: string;
}

export class InstitutionForUpdateDto implements IInstitutionForUpdateDto {
    name: string;
    accountId?: string;
    userId?: string;

    constructor(data?: IInstitutionForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): InstitutionForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IInstitutionForUpdateDto {
    name: string;
    accountId?: string;
    userId?: string;
}

export class ServiceResponseOfInstitutionDto extends ServiceResponse implements IServiceResponseOfInstitutionDto {
    data?: InstitutionDto;

    constructor(data?: IServiceResponseOfInstitutionDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? InstitutionDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfInstitutionDto extends IServiceResponse {
    data?: InstitutionDto;
}

export class InstitutionDto extends BaseDto implements IInstitutionDto {
    name: string;
    accountId?: string;
    accountName?: string;
    userId?: string;
    userName?: string;

    constructor(data?: IInstitutionDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
            this.userId = data["userId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): InstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        super.toJSON(data);
        return data; 
    }
}

export interface IInstitutionDto extends IBaseDto {
    name: string;
    accountId?: string;
    accountName?: string;
    userId?: string;
    userName?: string;
}

export class ServiceResponseOfListOfInstitutionDto extends ServiceResponse implements IServiceResponseOfListOfInstitutionDto {
    data?: InstitutionDto[];

    constructor(data?: IServiceResponseOfListOfInstitutionDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(InstitutionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfInstitutionDto extends IServiceResponse {
    data?: InstitutionDto[];
}

export class InvestorForCreationDto implements IInvestorForCreationDto {
    name: string;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    contactName?: string;
    contactPhone?: string;
    institutionId: string;

    constructor(data?: IInvestorForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.address = data["address"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
            this.contactName = data["contactName"];
            this.contactPhone = data["contactPhone"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): InvestorForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestorForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["contactName"] = this.contactName;
        data["contactPhone"] = this.contactPhone;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface IInvestorForCreationDto {
    name: string;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    contactName?: string;
    contactPhone?: string;
    institutionId: string;
}

export class InvestorForUpdateDto implements IInvestorForUpdateDto {
    name: string;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    contactName?: string;
    contactPhone?: string;
    institutionId: string;

    constructor(data?: IInvestorForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.address = data["address"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
            this.contactName = data["contactName"];
            this.contactPhone = data["contactPhone"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): InvestorForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestorForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["contactName"] = this.contactName;
        data["contactPhone"] = this.contactPhone;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface IInvestorForUpdateDto {
    name: string;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    contactName?: string;
    contactPhone?: string;
    institutionId: string;
}

export class ServiceResponseOfInvestorDto extends ServiceResponse implements IServiceResponseOfInvestorDto {
    data?: InvestorDto;

    constructor(data?: IServiceResponseOfInvestorDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? InvestorDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfInvestorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfInvestorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfInvestorDto extends IServiceResponse {
    data?: InvestorDto;
}

export class InvestorDto extends BaseDto implements IInvestorDto {
    institutionId: string;
    name: string;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    contactName?: string;
    contactPhone?: string;
    institutionName?: string;

    constructor(data?: IInvestorDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.institutionId = data["institutionId"];
            this.name = data["name"];
            this.address = data["address"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
            this.contactName = data["contactName"];
            this.contactPhone = data["contactPhone"];
            this.institutionName = data["institutionName"];
        }
    }

    static fromJS(data: any): InvestorDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institutionId"] = this.institutionId;
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["contactName"] = this.contactName;
        data["contactPhone"] = this.contactPhone;
        data["institutionName"] = this.institutionName;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvestorDto extends IBaseDto {
    institutionId: string;
    name: string;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    contactName?: string;
    contactPhone?: string;
    institutionName?: string;
}

export class ServiceResponseOfListOfInvestorDto extends ServiceResponse implements IServiceResponseOfListOfInvestorDto {
    data?: InvestorDto[];

    constructor(data?: IServiceResponseOfListOfInvestorDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(InvestorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfInvestorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfInvestorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfInvestorDto extends IServiceResponse {
    data?: InvestorDto[];
}

export class LoanForCreationDto implements ILoanForCreationDto {
    broker?: string;
    borrower?: string;
    accountManager?: string;
    propertyAddress?: string;
    propertyCity?: string;
    propertyState?: string;
    propertyZipCode?: string;
    loanNumber?: string;
    branchId?: string;
    loanType?: string;
    institutionId: string;

    constructor(data?: ILoanForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.broker = data["broker"];
            this.borrower = data["borrower"];
            this.accountManager = data["accountManager"];
            this.propertyAddress = data["propertyAddress"];
            this.propertyCity = data["propertyCity"];
            this.propertyState = data["propertyState"];
            this.propertyZipCode = data["propertyZipCode"];
            this.loanNumber = data["loanNumber"];
            this.branchId = data["branchId"];
            this.loanType = data["loanType"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): LoanForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["broker"] = this.broker;
        data["borrower"] = this.borrower;
        data["accountManager"] = this.accountManager;
        data["propertyAddress"] = this.propertyAddress;
        data["propertyCity"] = this.propertyCity;
        data["propertyState"] = this.propertyState;
        data["propertyZipCode"] = this.propertyZipCode;
        data["loanNumber"] = this.loanNumber;
        data["branchId"] = this.branchId;
        data["loanType"] = this.loanType;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface ILoanForCreationDto {
    broker?: string;
    borrower?: string;
    accountManager?: string;
    propertyAddress?: string;
    propertyCity?: string;
    propertyState?: string;
    propertyZipCode?: string;
    loanNumber?: string;
    branchId?: string;
    loanType?: string;
    institutionId: string;
}

export class LoanForUpdateDto implements ILoanForUpdateDto {
    broker?: string;
    borrower?: string;
    accountManager?: string;
    propertyAddress?: string;
    propertyCity?: string;
    propertyState?: string;
    propertyZipCode?: string;
    loanNumber?: string;
    branchId?: string;
    loanType?: string;
    institutionId: string;

    constructor(data?: ILoanForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.broker = data["broker"];
            this.borrower = data["borrower"];
            this.accountManager = data["accountManager"];
            this.propertyAddress = data["propertyAddress"];
            this.propertyCity = data["propertyCity"];
            this.propertyState = data["propertyState"];
            this.propertyZipCode = data["propertyZipCode"];
            this.loanNumber = data["loanNumber"];
            this.branchId = data["branchId"];
            this.loanType = data["loanType"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): LoanForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["broker"] = this.broker;
        data["borrower"] = this.borrower;
        data["accountManager"] = this.accountManager;
        data["propertyAddress"] = this.propertyAddress;
        data["propertyCity"] = this.propertyCity;
        data["propertyState"] = this.propertyState;
        data["propertyZipCode"] = this.propertyZipCode;
        data["loanNumber"] = this.loanNumber;
        data["branchId"] = this.branchId;
        data["loanType"] = this.loanType;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface ILoanForUpdateDto {
    broker?: string;
    borrower?: string;
    accountManager?: string;
    propertyAddress?: string;
    propertyCity?: string;
    propertyState?: string;
    propertyZipCode?: string;
    loanNumber?: string;
    branchId?: string;
    loanType?: string;
    institutionId: string;
}

export class ServiceResponseOfLoanDto extends ServiceResponse implements IServiceResponseOfLoanDto {
    data?: LoanDto;

    constructor(data?: IServiceResponseOfLoanDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? LoanDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfLoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfLoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfLoanDto extends IServiceResponse {
    data?: LoanDto;
}

export class LoanDto extends BaseDto implements ILoanDto {
    broker?: string;
    borrower?: string;
    accountManager?: string;
    propertyAddress?: string;
    propertyCity?: string;
    propertyState?: string;
    propertyZipCode?: string;
    loanNumber?: string;
    branchId?: string;
    loanType?: string;
    institutionId: string;
    institutionName?: string;

    constructor(data?: ILoanDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.broker = data["broker"];
            this.borrower = data["borrower"];
            this.accountManager = data["accountManager"];
            this.propertyAddress = data["propertyAddress"];
            this.propertyCity = data["propertyCity"];
            this.propertyState = data["propertyState"];
            this.propertyZipCode = data["propertyZipCode"];
            this.loanNumber = data["loanNumber"];
            this.branchId = data["branchId"];
            this.loanType = data["loanType"];
            this.institutionId = data["institutionId"];
            this.institutionName = data["institutionName"];
        }
    }

    static fromJS(data: any): LoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["broker"] = this.broker;
        data["borrower"] = this.borrower;
        data["accountManager"] = this.accountManager;
        data["propertyAddress"] = this.propertyAddress;
        data["propertyCity"] = this.propertyCity;
        data["propertyState"] = this.propertyState;
        data["propertyZipCode"] = this.propertyZipCode;
        data["loanNumber"] = this.loanNumber;
        data["branchId"] = this.branchId;
        data["loanType"] = this.loanType;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        super.toJSON(data);
        return data; 
    }
}

export interface ILoanDto extends IBaseDto {
    broker?: string;
    borrower?: string;
    accountManager?: string;
    propertyAddress?: string;
    propertyCity?: string;
    propertyState?: string;
    propertyZipCode?: string;
    loanNumber?: string;
    branchId?: string;
    loanType?: string;
    institutionId: string;
    institutionName?: string;
}

export class ServiceResponseOfListOfLoanDto extends ServiceResponse implements IServiceResponseOfListOfLoanDto {
    data?: LoanDto[];

    constructor(data?: IServiceResponseOfListOfLoanDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(LoanDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfLoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfLoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfLoanDto extends IServiceResponse {
    data?: LoanDto[];
}

export class InviteUserModel implements IInviteUserModel {
    institutionId?: string;
    accountId?: string;
    email: string;
    roleId: string;

    constructor(data?: IInviteUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.institutionId = data["institutionId"];
            this.accountId = data["accountId"];
            this.email = data["email"];
            this.roleId = data["roleId"];
        }
    }

    static fromJS(data: any): InviteUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new InviteUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institutionId"] = this.institutionId;
        data["accountId"] = this.accountId;
        data["email"] = this.email;
        data["roleId"] = this.roleId;
        return data; 
    }
}

export interface IInviteUserModel {
    institutionId?: string;
    accountId?: string;
    email: string;
    roleId: string;
}

export class ServiceResponseOfListOfUserModel extends ServiceResponse implements IServiceResponseOfListOfUserModel {
    data?: UserModel[];

    constructor(data?: IServiceResponseOfListOfUserModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(UserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfUserModel extends IServiceResponse {
    data?: UserModel[];
}

export class UserModel implements IUserModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    isInvited: boolean;
    emailConfirmed: boolean;
    role?: string;
    roleId?: string;
    phoneNumber?: string;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.isInvited = data["isInvited"];
            this.emailConfirmed = data["emailConfirmed"];
            this.role = data["role"];
            this.roleId = data["roleId"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["isInvited"] = this.isInvited;
        data["emailConfirmed"] = this.emailConfirmed;
        data["role"] = this.role;
        data["roleId"] = this.roleId;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUserModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    isInvited: boolean;
    emailConfirmed: boolean;
    role?: string;
    roleId?: string;
    phoneNumber?: string;
}

export class UpdatePasswordOfInvitedUserModel implements IUpdatePasswordOfInvitedUserModel {
    password: string;
    oldPassword: string;

    constructor(data?: IUpdatePasswordOfInvitedUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.oldPassword = data["oldPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordOfInvitedUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordOfInvitedUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["oldPassword"] = this.oldPassword;
        return data; 
    }
}

export interface IUpdatePasswordOfInvitedUserModel {
    password: string;
    oldPassword: string;
}

export class ServiceResponseOfListOfAspNetRoleDto extends ServiceResponse implements IServiceResponseOfListOfAspNetRoleDto {
    data?: AspNetRoleDto[];

    constructor(data?: IServiceResponseOfListOfAspNetRoleDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AspNetRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfAspNetRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfAspNetRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfAspNetRoleDto extends IServiceResponse {
    data?: AspNetRoleDto[];
}

export class AspNetRoleDto implements IAspNetRoleDto {
    id: string;
    concurrencyStamp?: string;
    name?: string;
    normalizedName?: string;

    constructor(data?: IAspNetRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.name = data["name"];
            this.normalizedName = data["normalizedName"];
        }
    }

    static fromJS(data: any): AspNetRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        return data; 
    }
}

export interface IAspNetRoleDto {
    id: string;
    concurrencyStamp?: string;
    name?: string;
    normalizedName?: string;
}

export class ServiceResponseOfStandardColorDto extends ServiceResponse implements IServiceResponseOfStandardColorDto {
    data?: StandardColorDto;

    constructor(data?: IServiceResponseOfStandardColorDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? StandardColorDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfStandardColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfStandardColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfStandardColorDto extends IServiceResponse {
    data?: StandardColorDto;
}

export class StandardColorDto extends BaseDto implements IStandardColorDto {
    name: string;
    fontColor: string;
    backGroundColor: string;
    disabled: boolean;
    institutionId: string;
    institutionName?: string;

    constructor(data?: IStandardColorDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.fontColor = data["fontColor"];
            this.backGroundColor = data["backGroundColor"];
            this.disabled = data["disabled"];
            this.institutionId = data["institutionId"];
            this.institutionName = data["institutionName"];
        }
    }

    static fromJS(data: any): StandardColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fontColor"] = this.fontColor;
        data["backGroundColor"] = this.backGroundColor;
        data["disabled"] = this.disabled;
        data["institutionId"] = this.institutionId;
        data["institutionName"] = this.institutionName;
        super.toJSON(data);
        return data; 
    }
}

export interface IStandardColorDto extends IBaseDto {
    name: string;
    fontColor: string;
    backGroundColor: string;
    disabled: boolean;
    institutionId: string;
    institutionName?: string;
}

export class StandardColorForCreationDto implements IStandardColorForCreationDto {
    name: string;
    fontColor: string;
    backGroundColor: string;
    disabled: boolean;
    institutionId: string;

    constructor(data?: IStandardColorForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.fontColor = data["fontColor"];
            this.backGroundColor = data["backGroundColor"];
            this.disabled = data["disabled"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): StandardColorForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardColorForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fontColor"] = this.fontColor;
        data["backGroundColor"] = this.backGroundColor;
        data["disabled"] = this.disabled;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface IStandardColorForCreationDto {
    name: string;
    fontColor: string;
    backGroundColor: string;
    disabled: boolean;
    institutionId: string;
}

export class StandardColorForUpdateDto implements IStandardColorForUpdateDto {
    name: string;
    fontColor: string;
    backGroundColor: string;
    disabled: boolean;
    institutionId: string;

    constructor(data?: IStandardColorForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.fontColor = data["fontColor"];
            this.backGroundColor = data["backGroundColor"];
            this.disabled = data["disabled"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): StandardColorForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandardColorForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fontColor"] = this.fontColor;
        data["backGroundColor"] = this.backGroundColor;
        data["disabled"] = this.disabled;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface IStandardColorForUpdateDto {
    name: string;
    fontColor: string;
    backGroundColor: string;
    disabled: boolean;
    institutionId: string;
}

export class ServiceResponseOfListOfStandardColorDto extends ServiceResponse implements IServiceResponseOfListOfStandardColorDto {
    data?: StandardColorDto[];

    constructor(data?: IServiceResponseOfListOfStandardColorDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(StandardColorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfStandardColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfStandardColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfStandardColorDto extends IServiceResponse {
    data?: StandardColorDto[];
}

export class ServiceResponseOfTaskStatusSetDto extends ServiceResponse implements IServiceResponseOfTaskStatusSetDto {
    data?: TaskStatusSetDto;

    constructor(data?: IServiceResponseOfTaskStatusSetDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? TaskStatusSetDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfTaskStatusSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfTaskStatusSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfTaskStatusSetDto extends IServiceResponse {
    data?: TaskStatusSetDto;
}

export class TaskStatusSetForCreationDto implements ITaskStatusSetForCreationDto {
    title: string;
    disabled: boolean;
    institutionId: string;

    constructor(data?: ITaskStatusSetForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.disabled = data["disabled"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): TaskStatusSetForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStatusSetForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["disabled"] = this.disabled;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface ITaskStatusSetForCreationDto {
    title: string;
    disabled: boolean;
    institutionId: string;
}

export class TaskStatusSetForUpdateDto implements ITaskStatusSetForUpdateDto {
    title: string;
    disabled: boolean;
    institutionId: string;

    constructor(data?: ITaskStatusSetForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.disabled = data["disabled"];
            this.institutionId = data["institutionId"];
        }
    }

    static fromJS(data: any): TaskStatusSetForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStatusSetForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["disabled"] = this.disabled;
        data["institutionId"] = this.institutionId;
        return data; 
    }
}

export interface ITaskStatusSetForUpdateDto {
    title: string;
    disabled: boolean;
    institutionId: string;
}

export class ServiceResponseOfListOfTaskStatusSetDto extends ServiceResponse implements IServiceResponseOfListOfTaskStatusSetDto {
    data?: TaskStatusSetDto[];

    constructor(data?: IServiceResponseOfListOfTaskStatusSetDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TaskStatusSetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfTaskStatusSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfTaskStatusSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfTaskStatusSetDto extends IServiceResponse {
    data?: TaskStatusSetDto[];
}

export class ServiceResponseOfTaskStatusDetailDto extends ServiceResponse implements IServiceResponseOfTaskStatusDetailDto {
    data?: TaskStatusDetailDto;

    constructor(data?: IServiceResponseOfTaskStatusDetailDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? TaskStatusDetailDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfTaskStatusDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfTaskStatusDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfTaskStatusDetailDto extends IServiceResponse {
    data?: TaskStatusDetailDto;
}

export class TaskStatusDetailForCreationDto implements ITaskStatusDetailForCreationDto {
    caption: string;
    color: string;
    backGroundColor: string;
    order: number;
    taskStatusSetId: string;
    disabled: boolean;
    taskStatusSetTitle?: string;

    constructor(data?: ITaskStatusDetailForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.caption = data["caption"];
            this.color = data["color"];
            this.backGroundColor = data["backGroundColor"];
            this.order = data["order"];
            this.taskStatusSetId = data["taskStatusSetId"];
            this.disabled = data["disabled"];
            this.taskStatusSetTitle = data["taskStatusSetTitle"];
        }
    }

    static fromJS(data: any): TaskStatusDetailForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStatusDetailForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caption"] = this.caption;
        data["color"] = this.color;
        data["backGroundColor"] = this.backGroundColor;
        data["order"] = this.order;
        data["taskStatusSetId"] = this.taskStatusSetId;
        data["disabled"] = this.disabled;
        data["taskStatusSetTitle"] = this.taskStatusSetTitle;
        return data; 
    }
}

export interface ITaskStatusDetailForCreationDto {
    caption: string;
    color: string;
    backGroundColor: string;
    order: number;
    taskStatusSetId: string;
    disabled: boolean;
    taskStatusSetTitle?: string;
}

export class TaskStatusDetailForUpdateDto implements ITaskStatusDetailForUpdateDto {
    caption: string;
    color: string;
    backGroundColor: string;
    order: number;
    taskStatusSetId: string;
    disabled: boolean;
    taskStatusSetTitle?: string;

    constructor(data?: ITaskStatusDetailForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.caption = data["caption"];
            this.color = data["color"];
            this.backGroundColor = data["backGroundColor"];
            this.order = data["order"];
            this.taskStatusSetId = data["taskStatusSetId"];
            this.disabled = data["disabled"];
            this.taskStatusSetTitle = data["taskStatusSetTitle"];
        }
    }

    static fromJS(data: any): TaskStatusDetailForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStatusDetailForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caption"] = this.caption;
        data["color"] = this.color;
        data["backGroundColor"] = this.backGroundColor;
        data["order"] = this.order;
        data["taskStatusSetId"] = this.taskStatusSetId;
        data["disabled"] = this.disabled;
        data["taskStatusSetTitle"] = this.taskStatusSetTitle;
        return data; 
    }
}

export interface ITaskStatusDetailForUpdateDto {
    caption: string;
    color: string;
    backGroundColor: string;
    order: number;
    taskStatusSetId: string;
    disabled: boolean;
    taskStatusSetTitle?: string;
}

export class ServiceResponseOfListOfTaskStatusDetailDto extends ServiceResponse implements IServiceResponseOfListOfTaskStatusDetailDto {
    data?: TaskStatusDetailDto[];

    constructor(data?: IServiceResponseOfListOfTaskStatusDetailDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(TaskStatusDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfTaskStatusDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfTaskStatusDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfTaskStatusDetailDto extends IServiceResponse {
    data?: TaskStatusDetailDto[];
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}