/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.18.1.0 (NJsonSchema v9.10.66.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { OAuthService } from 'app/services/o-auth.service';
import { Globals } from 'app/globals';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class BaseClient {
  private oAuthService: OAuthService;

  constructor() {
    this.oAuthService = Globals.injector.get(OAuthService);
  }

  protected transformOptions(options: any) {
    const timestamp = new Date();
    let customHeaders = new HttpHeaders();
    customHeaders = customHeaders.append('Access-Control-Allow-Origin', '*');
    customHeaders = customHeaders.append(
      'Content-Type',
      'application/json; charset=UTF-8'
    );
    if (this.oAuthService.getAuthorizationHeader() !== '') {
      customHeaders = customHeaders.append(
        'Authorization',
        this.oAuthService.getAuthorizationHeader()
      );
    }
    customHeaders = customHeaders.append('Accept', 'application/json');
    customHeaders = customHeaders.append('Cache-Control', 'no-cache');
    customHeaders = customHeaders.append('Pragma', 'no-cache');
    customHeaders = customHeaders.append(
      'X-REL-Timezone-Offset-Mins',
      (timestamp.getTimezoneOffset() * -1).toString()
    );
    customHeaders = customHeaders.append(
      'Access-Control-Allow-Methods',
      'PUT, GET, POST, DELETE, OPTIONS'
    );
    customHeaders = customHeaders.append(
      'Access-Control-Allow-Headers',
      'Origin, X-Requested-With, Content-Type, Accept, Authorization'
    );
    options.headers = customHeaders;
    return Promise.resolve(options);
  }
}

export interface IAccountsClient {
    create(account: AccountForCreationDto): Observable<ServiceResponseOfString>;
    getAccount(id: string): Observable<ServiceResponseOfAccountDto>;
    getAccounts(): Observable<ServiceResponseOfListOfAccountDto>;
    delete(id: string): Observable<ServiceResponse>;
    update(account: AccountForUpdateDto, id: string): Observable<ServiceResponse>;
    getStateList(): Observable<ServiceResponseOfListOfStateDto>;
}

@Injectable()
export class AccountsClient extends BaseClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(account: AccountForCreationDto): Observable<ServiceResponseOfString> {
        let url_ = this.baseUrl + "/api/accounts/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfString>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfString>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponseOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfString.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfString>(<any>null);
    }

    getAccount(id: string): Observable<ServiceResponseOfAccountDto> {
        let url_ = this.baseUrl + "/api/accounts/getaccount?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccount(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfAccountDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfAccountDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAccount(response: HttpResponseBase): Observable<ServiceResponseOfAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfAccountDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfAccountDto>(<any>null);
    }

    getAccounts(): Observable<ServiceResponseOfListOfAccountDto> {
        let url_ = this.baseUrl + "/api/accounts/getaccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAccounts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccounts(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfAccountDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfAccountDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<ServiceResponseOfListOfAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfAccountDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfAccountDto>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/accounts/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(account: AccountForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/accounts/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(account);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getStateList(): Observable<ServiceResponseOfListOfStateDto> {
        let url_ = this.baseUrl + "/api/accounts/getstatelist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetStateList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfStateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfStateDto>><any>Observable.throw(response_);
        });
    }

    protected processGetStateList(response: HttpResponseBase): Observable<ServiceResponseOfListOfStateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfStateDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfStateDto>(<any>null);
    }
}

export interface IAuthClient {
    login(model: LoginModel): Observable<ServiceResponseOfProfileViewModel>;
    register(model: RegisterModel): Observable<ServiceResponseOfProfileViewModel>;
    forgotPassword(email: string): Observable<ServiceResponse>;
    resetPassword(password: string, confirmPassword: string, code: string, userId: string): Observable<ServiceResponse>;
}

@Injectable()
export class AuthClient extends BaseClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    login(model: LoginModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    register(model: RegisterModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    forgotPassword(email: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/auth/forgotpassword?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processForgotPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    resetPassword(password: string, confirmPassword: string, code: string, userId: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/auth/resetpassword?";
        if (password === undefined)
            throw new Error("The parameter 'password' must be defined.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (confirmPassword !== undefined)
            url_ += "confirmPassword=" + encodeURIComponent("" + confirmPassword) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processResetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }
}

export interface ICheckListClient {
    create(checkList: CheckListForCreationDto): Observable<ServiceResponse>;
    delete(id: string): Observable<ServiceResponse>;
    update(checkList: CheckListForUpdateDto, id: string): Observable<ServiceResponse>;
    getCheckList(id: string): Observable<ServiceResponseOfCheckListDto>;
    getListOfCheckList(accountId: string): Observable<ServiceResponseOfListOfCheckListDto>;
}

@Injectable()
export class CheckListClient extends BaseClient implements ICheckListClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(checkList: CheckListForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklists/delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(checkList: CheckListForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/checklists/update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getCheckList(id: string): Observable<ServiceResponseOfCheckListDto> {
        let url_ = this.baseUrl + "/api/checklists/getchecklist?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetCheckList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfCheckListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfCheckListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCheckList(response: HttpResponseBase): Observable<ServiceResponseOfCheckListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfCheckListDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfCheckListDto>(<any>null);
    }

    getListOfCheckList(accountId: string): Observable<ServiceResponseOfListOfCheckListDto> {
        let url_ = this.baseUrl + "/api/checklists/getlistofchecklist?";
        if (accountId === undefined)
            throw new Error("The parameter 'accountId' must be defined.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetListOfCheckList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfCheckList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfCheckListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfCheckListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetListOfCheckList(response: HttpResponseBase): Observable<ServiceResponseOfListOfCheckListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfCheckListDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfCheckListDto>(<any>null);
    }
}

export interface ICheckListItemsClient {
    get(checkListId: string, id: string): Observable<FileResponse>;
    create(checkListId: string, checkListItem: CheckListItemForCreationDto): Observable<FileResponse>;
}

@Injectable()
export class CheckListItemsClient extends BaseClient implements ICheckListItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    get(checkListId: string, id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/checklists/{checklistid}/checklistitems/GetListItem?";
        if (checkListId === undefined || checkListId === null)
            throw new Error("The parameter 'checkListId' must be defined.");
        url_ = url_.replace("{checkListId}", encodeURIComponent("" + checkListId)); 
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse>(<any>null);
    }

    create(checkListId: string, checkListItem: CheckListItemForCreationDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/checklists/{checklistid}/checklistitems/Create";
        if (checkListId === undefined || checkListId === null)
            throw new Error("The parameter 'checkListId' must be defined.");
        url_ = url_.replace("{checkListId}", encodeURIComponent("" + checkListId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkListItem);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse>(<any>null);
    }
}

export interface IInstitutionClient {
    create(institution: InstitutionForCreationDto): Observable<ServiceResponse>;
    delete(id: string): Observable<ServiceResponse>;
    update(institution: InstitutionForUpdateDto, id: string): Observable<ServiceResponse>;
    getInstitution(id: string): Observable<ServiceResponseOfInstitutionDto>;
    getInstitutionList(accountId: string): Observable<ServiceResponseOfListOfInstitutionDto>;
}

@Injectable()
export class InstitutionClient extends BaseClient implements IInstitutionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    create(institution: InstitutionForCreationDto): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/institutions/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(institution);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    delete(id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/institutions/Delete?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    update(institution: InstitutionForUpdateDto, id: string): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/institutions/Update?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(institution);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getInstitution(id: string): Observable<ServiceResponseOfInstitutionDto> {
        let url_ = this.baseUrl + "/api/institutions/getinstitution?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetInstitution(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitution(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfInstitutionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfInstitutionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInstitution(response: HttpResponseBase): Observable<ServiceResponseOfInstitutionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfInstitutionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfInstitutionDto>(<any>null);
    }

    getInstitutionList(accountId: string): Observable<ServiceResponseOfListOfInstitutionDto> {
        let url_ = this.baseUrl + "/api/institutions/getinstitutionlist?";
        if (accountId === undefined)
            throw new Error("The parameter 'accountId' must be defined.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetInstitutionList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitutionList(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfInstitutionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfInstitutionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInstitutionList(response: HttpResponseBase): Observable<ServiceResponseOfListOfInstitutionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfInstitutionDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfInstitutionDto>(<any>null);
    }
}

export interface IManageUserClient {
    inviteUser(model: InviteUserModel): Observable<ServiceResponse>;
    getRegisterdUsersByAccount(accountId: string): Observable<ServiceResponseOfListOfUserModel>;
    updatePasswordOfInvitedUser(model: UpdatePasswordOfInvitedUserModel): Observable<ServiceResponseOfProfileViewModel>;
    getRoles(): Observable<ServiceResponseOfListOfAspNetRoleDto>;
    updateUserDetail(model: UserModel): Observable<ServiceResponseOfProfileViewModel>;
}

@Injectable()
export class ManageUserClient extends BaseClient implements IManageUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44354";
    }

    inviteUser(model: InviteUserModel): Observable<ServiceResponse> {
        let url_ = this.baseUrl + "/api/manageuser/inviteuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processInviteUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponse>><any>Observable.throw(response_);
        });
    }

    protected processInviteUser(response: HttpResponseBase): Observable<ServiceResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponse.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponse>(<any>null);
    }

    getRegisterdUsersByAccount(accountId: string): Observable<ServiceResponseOfListOfUserModel> {
        let url_ = this.baseUrl + "/api/manageuser/getregisterdusersbyaccount?";
        if (accountId === undefined)
            throw new Error("The parameter 'accountId' must be defined.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetRegisterdUsersByAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegisterdUsersByAccount(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfUserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfUserModel>><any>Observable.throw(response_);
        });
    }

    protected processGetRegisterdUsersByAccount(response: HttpResponseBase): Observable<ServiceResponseOfListOfUserModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfUserModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfUserModel>(<any>null);
    }

    updatePasswordOfInvitedUser(model: UpdatePasswordOfInvitedUserModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/manageuser/updatepasswordofinviteduser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdatePasswordOfInvitedUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordOfInvitedUser(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePasswordOfInvitedUser(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }

    getRoles(): Observable<ServiceResponseOfListOfAspNetRoleDto> {
        let url_ = this.baseUrl + "/api/manageuser/getroles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfListOfAspNetRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfListOfAspNetRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ServiceResponseOfListOfAspNetRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfListOfAspNetRoleDto.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfListOfAspNetRoleDto>(<any>null);
    }

    updateUserDetail(model: UserModel): Observable<ServiceResponseOfProfileViewModel> {
        let url_ = this.baseUrl + "/api/manageuser/updateuserdetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateUserDetail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserDetail(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceResponseOfProfileViewModel>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUserDetail(response: HttpResponseBase): Observable<ServiceResponseOfProfileViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResponseOfProfileViewModel.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServiceResponseOfProfileViewModel>(<any>null);
    }
}

export class AccountForCreationDto implements IAccountForCreationDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;

    constructor(data?: IAccountForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.street1 = data["street1"];
            this.street2 = data["street2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): AccountForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["street1"] = this.street1;
        data["street2"] = this.street2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IAccountForCreationDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;
}

export class ServiceResponse implements IServiceResponse {
    errorMessages?: ValidationFailure[];
    successful: boolean;

    constructor(data?: IServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["errorMessages"] && data["errorMessages"].constructor === Array) {
                this.errorMessages = [];
                for (let item of data["errorMessages"])
                    this.errorMessages.push(ValidationFailure.fromJS(item));
            }
            this.successful = data["successful"];
        }
    }

    static fromJS(data: any): ServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errorMessages && this.errorMessages.constructor === Array) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item.toJSON());
        }
        data["successful"] = this.successful;
        return data; 
    }
}

export interface IServiceResponse {
    errorMessages?: ValidationFailure[];
    successful: boolean;
}

export class ServiceResponseOfString extends ServiceResponse implements IServiceResponseOfString {
    data?: string;

    constructor(data?: IServiceResponseOfString) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"];
        }
    }

    static fromJS(data: any): ServiceResponseOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfString extends IServiceResponse {
    data?: string;
}

/** Defines a validation failure */
export class ValidationFailure implements IValidationFailure {
    /** The name of the property. */
    propertyName?: string;
    /** The error message */
    errorMessage?: string;
    /** The property value that caused the failure. */
    attemptedValue?: any;
    /** Custom state associated with the failure. */
    customState?: any;
    /** Custom severity level associated with the failure. */
    severity: Severity;
    /** Gets or sets the error code. */
    errorCode?: string;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[];
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; };
    /** The resource name used for building the message */
    resourceName?: string;

    constructor(data?: IValidationFailure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.errorMessage = data["errorMessage"];
            this.attemptedValue = data["attemptedValue"];
            this.customState = data["customState"];
            this.severity = data["severity"];
            this.errorCode = data["errorCode"];
            if (data["formattedMessageArguments"] && data["formattedMessageArguments"].constructor === Array) {
                this.formattedMessageArguments = [];
                for (let item of data["formattedMessageArguments"])
                    this.formattedMessageArguments.push(item);
            }
            if (data["formattedMessagePlaceholderValues"]) {
                this.formattedMessagePlaceholderValues = {};
                for (let key in data["formattedMessagePlaceholderValues"]) {
                    if (data["formattedMessagePlaceholderValues"].hasOwnProperty(key))
                        this.formattedMessagePlaceholderValues[key] = data["formattedMessagePlaceholderValues"][key];
                }
            }
            this.resourceName = data["resourceName"];
        }
    }

    static fromJS(data: any): ValidationFailure {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFailure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["customState"] = this.customState;
        data["severity"] = this.severity;
        data["errorCode"] = this.errorCode;
        if (this.formattedMessageArguments && this.formattedMessageArguments.constructor === Array) {
            data["formattedMessageArguments"] = [];
            for (let item of this.formattedMessageArguments)
                data["formattedMessageArguments"].push(item);
        }
        if (this.formattedMessagePlaceholderValues) {
            data["formattedMessagePlaceholderValues"] = {};
            for (let key in this.formattedMessagePlaceholderValues) {
                if (this.formattedMessagePlaceholderValues.hasOwnProperty(key))
                    data["formattedMessagePlaceholderValues"][key] = this.formattedMessagePlaceholderValues[key];
            }
        }
        data["resourceName"] = this.resourceName;
        return data; 
    }
}

/** Defines a validation failure */
export interface IValidationFailure {
    /** The name of the property. */
    propertyName?: string;
    /** The error message */
    errorMessage?: string;
    /** The property value that caused the failure. */
    attemptedValue?: any;
    /** Custom state associated with the failure. */
    customState?: any;
    /** Custom severity level associated with the failure. */
    severity: Severity;
    /** Gets or sets the error code. */
    errorCode?: string;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[];
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; };
    /** The resource name used for building the message */
    resourceName?: string;
}

/** Specifies the severity of a rule. */
export enum Severity {
    Error = 0, 
    Warning = 1, 
    Info = 2, 
}

export class ServiceResponseOfAccountDto extends ServiceResponse implements IServiceResponseOfAccountDto {
    data?: AccountDto;

    constructor(data?: IServiceResponseOfAccountDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? AccountDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfAccountDto extends IServiceResponse {
    data?: AccountDto;
}

export class AccountDto implements IAccountDto {
    id: string;
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.street1 = data["street1"];
            this.street2 = data["street2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["street1"] = this.street1;
        data["street2"] = this.street2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IAccountDto {
    id: string;
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;
}

export class ServiceResponseOfListOfAccountDto extends ServiceResponse implements IServiceResponseOfListOfAccountDto {
    data?: AccountDto[];

    constructor(data?: IServiceResponseOfListOfAccountDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfAccountDto extends IServiceResponse {
    data?: AccountDto[];
}

export class AccountForUpdateDto implements IAccountForUpdateDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;

    constructor(data?: IAccountForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.street1 = data["street1"];
            this.street2 = data["street2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): AccountForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["street1"] = this.street1;
        data["street2"] = this.street2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IAccountForUpdateDto {
    name: string;
    street1: string;
    street2?: string;
    city: string;
    state: string;
    zipCode: string;
}

export class ServiceResponseOfListOfStateDto extends ServiceResponse implements IServiceResponseOfListOfStateDto {
    data?: StateDto[];

    constructor(data?: IServiceResponseOfListOfStateDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(StateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfStateDto extends IServiceResponse {
    data?: StateDto[];
}

export class StateDto implements IStateDto {
    id?: string;
    code: string;
    name: string;

    constructor(data?: IStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): StateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStateDto {
    id?: string;
    code: string;
    name: string;
}

export class LoginModel implements ILoginModel {
    email: string;
    password: string;
    rememberMe: boolean;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.password = data["password"];
            this.rememberMe = data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ILoginModel {
    email: string;
    password: string;
    rememberMe: boolean;
}

export class ServiceResponseOfProfileViewModel extends ServiceResponse implements IServiceResponseOfProfileViewModel {
    data?: ProfileViewModel;

    constructor(data?: IServiceResponseOfProfileViewModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? ProfileViewModel.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfProfileViewModel extends IServiceResponse {
    data?: ProfileViewModel;
}

export class ProfileViewModel implements IProfileViewModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    token?: string;
    accountId?: string;
    isInvited: boolean;
    phoneNumber?: string;
    emailConfirmed: boolean;

    constructor(data?: IProfileViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.token = data["token"];
            this.accountId = data["accountId"];
            this.isInvited = data["isInvited"];
            this.phoneNumber = data["phoneNumber"];
            this.emailConfirmed = data["emailConfirmed"];
        }
    }

    static fromJS(data: any): ProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["token"] = this.token;
        data["accountId"] = this.accountId;
        data["isInvited"] = this.isInvited;
        data["phoneNumber"] = this.phoneNumber;
        data["emailConfirmed"] = this.emailConfirmed;
        return data; 
    }
}

export interface IProfileViewModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    token?: string;
    accountId?: string;
    isInvited: boolean;
    phoneNumber?: string;
    emailConfirmed: boolean;
}

export class RegisterModel implements IRegisterModel {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    confirmPassword?: string;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.password = data["password"];
            this.confirmPassword = data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IRegisterModel {
    userName: string;
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    confirmPassword?: string;
}

export class CheckListForCreationDto implements ICheckListForCreationDto {
    name: string;
    accountId?: string;

    constructor(data?: ICheckListForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
        }
    }

    static fromJS(data: any): CheckListForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        return data; 
    }
}

export interface ICheckListForCreationDto {
    name: string;
    accountId?: string;
}

export class CheckListForUpdateDto implements ICheckListForUpdateDto {
    name: string;
    accountId?: string;

    constructor(data?: ICheckListForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
        }
    }

    static fromJS(data: any): CheckListForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        return data; 
    }
}

export interface ICheckListForUpdateDto {
    name: string;
    accountId?: string;
}

export class ServiceResponseOfCheckListDto extends ServiceResponse implements IServiceResponseOfCheckListDto {
    data?: CheckListDto;

    constructor(data?: IServiceResponseOfCheckListDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? CheckListDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfCheckListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfCheckListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfCheckListDto extends IServiceResponse {
    data?: CheckListDto;
}

export class BaseDto implements IBaseDto {
    id: string;
    createdDate: Date;
    modifiedDate: Date;

    constructor(data?: IBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBaseDto {
    id: string;
    createdDate: Date;
    modifiedDate: Date;
}

export class CheckListDto extends BaseDto implements ICheckListDto {
    name: string;
    accountId?: string;
    accountName?: string;

    constructor(data?: ICheckListDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
        }
    }

    static fromJS(data: any): CheckListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        super.toJSON(data);
        return data; 
    }
}

export interface ICheckListDto extends IBaseDto {
    name: string;
    accountId?: string;
    accountName?: string;
}

export class ServiceResponseOfListOfCheckListDto extends ServiceResponse implements IServiceResponseOfListOfCheckListDto {
    data?: CheckListDto[];

    constructor(data?: IServiceResponseOfListOfCheckListDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(CheckListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfCheckListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfCheckListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfCheckListDto extends IServiceResponse {
    data?: CheckListDto[];
}

export class CheckListItemForCreationDto implements ICheckListItemForCreationDto {
    checkListId: string;
    order: number;
    prompt: string;
    answerSetId: string;

    constructor(data?: ICheckListItemForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkListId = data["checkListId"];
            this.order = data["order"];
            this.prompt = data["prompt"];
            this.answerSetId = data["answerSetId"];
        }
    }

    static fromJS(data: any): CheckListItemForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckListItemForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkListId"] = this.checkListId;
        data["order"] = this.order;
        data["prompt"] = this.prompt;
        data["answerSetId"] = this.answerSetId;
        return data; 
    }
}

export interface ICheckListItemForCreationDto {
    checkListId: string;
    order: number;
    prompt: string;
    answerSetId: string;
}

export class InstitutionForCreationDto implements IInstitutionForCreationDto {
    name: string;
    accountId?: string;

    constructor(data?: IInstitutionForCreationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
        }
    }

    static fromJS(data: any): InstitutionForCreationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionForCreationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        return data; 
    }
}

export interface IInstitutionForCreationDto {
    name: string;
    accountId?: string;
}

export class InstitutionForUpdateDto implements IInstitutionForUpdateDto {
    name: string;
    accountId?: string;

    constructor(data?: IInstitutionForUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
        }
    }

    static fromJS(data: any): InstitutionForUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionForUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        return data; 
    }
}

export interface IInstitutionForUpdateDto {
    name: string;
    accountId?: string;
}

export class ServiceResponseOfInstitutionDto extends ServiceResponse implements IServiceResponseOfInstitutionDto {
    data?: InstitutionDto;

    constructor(data?: IServiceResponseOfInstitutionDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? InstitutionDto.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceResponseOfInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfInstitutionDto extends IServiceResponse {
    data?: InstitutionDto;
}

export class InstitutionDto extends BaseDto implements IInstitutionDto {
    name: string;
    accountId?: string;
    accountName?: string;

    constructor(data?: IInstitutionDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
        }
    }

    static fromJS(data: any): InstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        super.toJSON(data);
        return data; 
    }
}

export interface IInstitutionDto extends IBaseDto {
    name: string;
    accountId?: string;
    accountName?: string;
}

export class ServiceResponseOfListOfInstitutionDto extends ServiceResponse implements IServiceResponseOfListOfInstitutionDto {
    data?: InstitutionDto[];

    constructor(data?: IServiceResponseOfListOfInstitutionDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(InstitutionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfInstitutionDto extends IServiceResponse {
    data?: InstitutionDto[];
}

export class InviteUserModel implements IInviteUserModel {
    accountId: string;
    email: string;
    roleId: string;

    constructor(data?: IInviteUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.email = data["email"];
            this.roleId = data["roleId"];
        }
    }

    static fromJS(data: any): InviteUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new InviteUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["email"] = this.email;
        data["roleId"] = this.roleId;
        return data; 
    }
}

export interface IInviteUserModel {
    accountId: string;
    email: string;
    roleId: string;
}

export class ServiceResponseOfListOfUserModel extends ServiceResponse implements IServiceResponseOfListOfUserModel {
    data?: UserModel[];

    constructor(data?: IServiceResponseOfListOfUserModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(UserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfUserModel extends IServiceResponse {
    data?: UserModel[];
}

export class UserModel implements IUserModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    isInvited: boolean;
    emailConfirmed: boolean;
    role?: string;
    roleId?: string;
    phoneNumber?: string;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.isInvited = data["isInvited"];
            this.emailConfirmed = data["emailConfirmed"];
            this.role = data["role"];
            this.roleId = data["roleId"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["isInvited"] = this.isInvited;
        data["emailConfirmed"] = this.emailConfirmed;
        data["role"] = this.role;
        data["roleId"] = this.roleId;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUserModel {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    isInvited: boolean;
    emailConfirmed: boolean;
    role?: string;
    roleId?: string;
    phoneNumber?: string;
}

export class UpdatePasswordOfInvitedUserModel implements IUpdatePasswordOfInvitedUserModel {
    password: string;
    oldPassword: string;

    constructor(data?: IUpdatePasswordOfInvitedUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.oldPassword = data["oldPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordOfInvitedUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordOfInvitedUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["oldPassword"] = this.oldPassword;
        return data; 
    }
}

export interface IUpdatePasswordOfInvitedUserModel {
    password: string;
    oldPassword: string;
}

export class ServiceResponseOfListOfAspNetRoleDto extends ServiceResponse implements IServiceResponseOfListOfAspNetRoleDto {
    data?: AspNetRoleDto[];

    constructor(data?: IServiceResponseOfListOfAspNetRoleDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(AspNetRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceResponseOfListOfAspNetRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResponseOfListOfAspNetRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceResponseOfListOfAspNetRoleDto extends IServiceResponse {
    data?: AspNetRoleDto[];
}

export class AspNetRoleDto implements IAspNetRoleDto {
    id: string;
    concurrencyStamp?: string;
    name?: string;
    normalizedName?: string;

    constructor(data?: IAspNetRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.name = data["name"];
            this.normalizedName = data["normalizedName"];
        }
    }

    static fromJS(data: any): AspNetRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        return data; 
    }
}

export interface IAspNetRoleDto {
    id: string;
    concurrencyStamp?: string;
    name?: string;
    normalizedName?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}